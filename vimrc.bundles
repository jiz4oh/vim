" Install vim-plug if not found
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://cdn.jsdelivr.net/gh/junegunn/vim-plug@master/plug.vim
endif

nnoremap <silent> <leader><leader>i :PlugInstall <CR>
set updatetime=100
"Run PlugInstall if there are missing plugins
"autocmd VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  "\| PlugInstall --sync | source $MYVIMRC
"\| endif

call plug#begin('~/.vim/bundle')
Plug 'sonph/onehalf', { 'rtp': 'vim' }
"Plug 'vim-airline/vim-airline'
"let g:airline_theme='onehalfdark'

" https://github.com/easymotion/vim-easymotion
Plug 'easymotion/vim-easymotion', {'on':
   \ [
   \ '<Plug>(easymotion-bd-f)', '<Plug>(easymotion-overwin-f)',
   \ '<Plug>(easymotion-bd-f2)', '<Plug>(easymotion-overwin-f2)',
   \ '<Plug>(easymotion-bd-jk)', '<Plug>(easymotion-overwin-line)',
   \ '<Plug>(easymotion-bd-w)', '<Plug>(easymotion-overwin-w)', 
   \ ]}

" disable default mappings
let g:EasyMotion_do_mapping = 0
" turn on case-insensitive feature
let g:EasyMotion_smartcase = 1
" `s{char}`
map f <Plug>(easymotion-bd-f)
nmap f <Plug>(easymotion-overwin-f)

" use s to quick search
" `s{char}{label}`
map s <Plug>(easymotion-bd-f2)
nmap s <Plug>(easymotion-overwin-f2)
" move to word
map  F <Plug>(easymotion-bd-w)
nmap F <Plug>(easymotion-overwin-w)

" move to line
map  gl <Plug>(easymotion-bd-jk)
nmap gl <Plug>(easymotion-overwin-line)

" https://github.com/preservim/nerdcommenter
Plug 'preservim/nerdcommenter'

Plug 'preservim/tagbar', { 'on': 'TagbarToggle' }
nnoremap <silent> <leader>m :TagbarToggle<CR>

" fuzzy finder 
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
let $FZF_DEFAULT_OPTS="--reverse --preview-window 'down:50%'
  \ --bind ctrl-u:half-page-up,ctrl-d:half-page-down,
  \ctrl-b:page-up,ctrl-f:page-down,
  \alt-u:preview-half-page-up,alt-d:preview-half-page-down,
  \alt-b:preview-page-up,alt-f:preview-page-down
  \"

" jump to existed window if possible
let g:fzf_buffers_jump = 1
let g:fzf_history_dir = '~/.local/share/fzf-history'
if exists('$TMUX')
  let g:fzf_layout = { 'tmux': '-p90%,60%' }
else
  "disable popup in favor of location window
  let g:fzf_layout = { 'down': '60%' }

  "let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.9, 'relative': v:true, } }
endif

Plug 'junegunn/fzf.vim'
command! -bang -nargs=* Tags call fzf#vim#tags(<q-args>, fzf#vim#with_preview({ 'dir': systemlist('git rev-parse --show-toplevel 2>/dev/null || pwd')[0], "placeholder": "--tag {2}:{-1}:{3..}" }), <bang>0)
augroup update_bat_theme
    autocmd!
    autocmd colorscheme * call ToggleBatEnvVar()
augroup end
function ToggleBatEnvVar()
    if (&background == "dark")
        let $BAT_THEME='OneHalfDark'
    else
        let $BAT_THEME=''
    endif
endfunction

"search current dir
nnoremap <silent> <leader>sd :Files<Cr>
"search current files
nnoremap <silent> <Leader>sf :BLines<CR>
nnoremap <silent> <expr> <leader>swf ':BLines '.expand('<cword>').'<CR>'
vnoremap <silent> <leader>swf y:BLines <c-r>"<cr>
"search history
nnoremap <silent> <leader>sh :History<CR>

" `brew install ripgrep` before you use rg command
if executable('rg')
  let $FZF_DEFAULT_COMMAND='rg --files --hidden -g "!{.git}/*" 2>/dev/null'

  function! s:git_repo()
    return trim(system('git rev-parse --show-toplevel 2>/dev/null'))
  endfunction

  function! s:git_branch_name()
    return trim(system('git rev-parse --abbrev-ref HEAD'))
  endfunction

  let s:rg_command_fmt = 'rg --column --line-number --no-heading --smart-case %s || true'

  function! GitGrep(query, fullscreen, nth = 1)
    let rg_command = printf(s:rg_command_fmt, '--color=always '.shellescape(a:query))
    "let repo_name = split(s:git_repo(), '/')[-1]
    call fzf#vim#grep(rg_command, 1, fzf#vim#with_preview({'dir': s:git_repo(), 'options': ['--prompt', s:git_branch_name().'> ','--delimiter', ':', '--nth', a:nth.'..']}), a:fullscreen)
  endfunction

  command! -nargs=* -bang GitGrep call GitGrep(<q-args>, <bang>0, 1)
  command! -nargs=* -bang GGrep call GitGrep(<q-args>, <bang>0, 1)

  function! RG(query, fullscreen)
    let rg_command = printf(s:rg_command_fmt, '--color=always '.shellescape(a:query))
    let grep_opts = fzf#vim#with_preview({'options': ['--prompt', getcwd().'> ', '--delimiter', ':', '--nth', 4.'..']})
    if !empty(s:git_repo())
      "search file name together in git repo
      try
        call GitGrep(a:query, a:fullscreen, 1)
      catch
        call fzf#vim#grep(rg_command, 1, grep_opts, a:fullscreen)
      endtry
    else
      "only search file content in cwd
      call fzf#vim#grep(rg_command, 1, grep_opts, a:fullscreen)
    endif
  endfunction

  command! -nargs=* -bang RG call RG(<q-args>, <bang>0)
  " search current project or current dir
  nnoremap <silent> <leader>sp :RG<Cr>

  nnoremap <silent> <expr> <leader>swp ':RG '.expand('<cword>').'<CR>'
  " search selected word
  vnoremap <silent> <leader>swp y:RG <c-r>"<cr>

  function! s:gem_content_search(gem, query, fullscreen)
    let gemdir = substitute(system("bundle show " . a:gem), '\n\+$', '', '')
    let rg_command = printf(s:rg_command_fmt, shellescape(a:query))
    "call fzf#run(fzf#wrap(fzf#vim#with_preview({'source': rg_command, 'dir': gemdir, 'options': ['--prompt', a:gem.'> ']}), a:fullscreen))
    call fzf#vim#grep(rg_command, 1, fzf#vim#with_preview({'dir': gemdir, 'options': ['--prompt', a:gem.'> ']}), a:fullscreen)
  endfunction

  " Gem search
  function! GemSearch(query, fullscreen)
    call fzf#vim#grep("bundle list | sed '1d;$d' | cut -d ' ' -f 4", 0, {'sink': {gem -> s:gem_content_search(gem, a:query, a:fullscreen)}}, a:fullscreen)
  endfunction

  command! -nargs=* -bang Gems call GemSearch(<q-args>, <bang>0)
  nnoremap <leader>sg :Gems<CR>
endif
" markdown preview
" npm -g install instant-markdown-d
Plug 'instant-markdown/vim-instant-markdown', {'for': 'markdown'}

Plug 'airblade/vim-gitgutter'
Plug 'tpope/vim-fugitive'
" 添加当前文件到index
nnoremap <leader>gw <esc>:Gwrite<cr>
" 提交
nnoremap <leader>gc <esc>:Git commit<cr>
" 恢复当前文件到上个版本
nnoremap <leader>gr <esc>:Gread<cr>
" 查看当前文件与提交文件的不同
nnoremap <leader>gf <esc>:Gvdiffsplit<cr>
nnoremap <leader>gb <esc>:Git blame<cr>
nnoremap <leader>gl <esc>:Git log<cr>
nnoremap <leader>gg <esc>:Git<cr>
Plug 'tpope/vim-endwise'

Plug 'preservim/nerdtree' |
      \ Plug 'Xuyuanp/nerdtree-git-plugin'

let g:NERDTreeGitStatusIndicatorMapCustom = {
  \ "Modified"  : "✹",
  \ "Staged"    : "✚",
  \ "Untracked" : "✭",
  \ "Renamed"   : "➜",
  \ "Unmerged"  : "═",
  \ "Deleted"   : "✖",
  \ "Dirty"     : "✗",
  \ "Clean"     : "✔︎",
  \ 'Ignored'   : '☒',
  \ "Unknown"   : "?"
  \ }

nnoremap <expr> <leader>ee g:NERDTree.IsOpen() ? ":NERDTreeClose\<CR>" : ":NERDTreeMirror\<CR>:NERDTreeFind\<CR>"
nnoremap <leader>ep :NERDTreeMirror<CR>:NERDTreeToggleVCS<CR>

let NERDTreeMinimalUI = 1 " 最小化显示，不显示问号
let NERDTreeDirArrows = 1
let NERDChristmasTree = 1
" 如果使用vim-plug的话，加上这一句可以避免光标在nerdtree
" 中的时候进行插件升级而导致nerdtree崩溃
let NERDTreeAutoDeleteBuffer = 1
" 进入目录自动将workspace更改为此目录
let g:NERDTreeChDirMode = 2

"remove e mapping
let g:NERDTreeMapOpenExpl  = ''
let g:NERDTreeMapOpenSplit = "w"
let g:NERDTreeMapOpenVSplit = "W"
let g:NERDTreeMapActivateNode = 'l'
let g:NERDTreeMapPreview= 'gp'
let g:NERDTreeMapOpenRecursively = 'L'
let g:NERDTreeMapCloseDir = 'h'
let gLNERDTreeMapCloseChildren = 'H'
" 回到上一级目录
let g:NERDTreeMapUpdirKeepOpen = '<backspace>'

function! s:NERDTreeCustomCROpen(node) abort
  let l:newRoot = a:node.GetSelected()

  if l:newRoot.path.isDirectory
    call b:NERDTree.changeRoot(l:newRoot)
  else
    call l:newRoot.activate({'reuse': 'all', 'where': 'p'})
  endif
endfunction

augroup nerdtree_group
  " Exit Vim if NERDTree is the only window remaining in the only tab.
  autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif

  autocmd FileType nerdtree nmap <buffer> <CR> bb
  autocmd VimEnter * call NERDTreeAddKeyMap({
      \ 'key': 'bb',
      \ 'callback': function('<SID>NERDTreeCustomCROpen'),
      \ 'quickhelpText': 'go to dir and change cwd to it or open a file',
      \ 'scope': 'Node',
      \ 'override': 1,
      \ })
augroup END

if has('nvim')
  Plug 'neovim/nvim-lspconfig'
  "autocomplte
  Plug 'hrsh7th/cmp-nvim-lsp'
  Plug 'hrsh7th/cmp-buffer'
  Plug 'hrsh7th/cmp-path'
  Plug 'hrsh7th/cmp-cmdline'
  Plug 'hrsh7th/nvim-cmp'
  "fzf integration
  "https://github.com/ojroques/nvim-lspfuzzy
  Plug 'ojroques/nvim-lspfuzzy'
endif
"endif

"========================================= ruby develop environment =========================================
Plug 'vim-ruby/vim-ruby', { 'for': ['ruby'] }
Plug 'tpope/vim-bundler'
Plug 'tpope/vim-rails'

"======================================== scheme develop environment ========================================
" lisp IDE
Plug 'vlime/vlime', {'rtp': 'vim/'}

Plug 'kovisoft/paredit', { 'for': ['clojure', 'scheme'] }
autocmd filetype lisp,scheme,art setlocal equalprg=scmindent.rkt

"===========================================================================================================

Plug 'mhinz/vim-startify'
" returns all modified files of the current git repo
" `2>/dev/null` makes the command fail quietly, so that when we are not
" in a git repo, the list will be empty
function! s:gitModified()
    let files = systemlist('git ls-files -m 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

" same as above, but show untracked files, honouring .gitignore
function! s:gitUntracked()
    let files = systemlist('git ls-files -o --exclude-standard 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

let g:startify_lists = [
        \ { 'type': 'sessions',  'header': ['   Sessions']       },
        \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
        \ { 'type': 'files',     'header': ['   MRU']            },
        \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
        \ { 'type': function('s:gitModified'),  'header': ['   git modified']},
        \ { 'type': function('s:gitUntracked'), 'header': ['   git untracked']},
        \ { 'type': 'commands',  'header': ['   Commands']       },
        \ ]
call plug#end()

colorscheme onehalfdark


if has('nvim')

set completeopt=menu,menuone,noselect
lua << EOF
  local cmp = require'cmp'

  -- default config
  -- https://github.com/hrsh7th/nvim-cmp/blob/main/lua/cmp/config/default.lua
  cmp.setup({
    mapping = {
      ['<C-k>'] = cmp.mapping.select_prev_item(),
      ['<C-j>'] = cmp.mapping.select_next_item(),
      ['<C-y>'] = cmp.config.disable, -- Specify `cmp.config.disable` if you want to remove the default `<C-y>` mapping.
      ['<C-e>'] = cmp.config.disable,
      ['<C-u>'] = cmp.mapping(cmp.mapping.scroll_docs(-4), { 'i', 'c' }),
      ['<C-d>'] = cmp.mapping(cmp.mapping.scroll_docs(4), { 'i', 'c' }),
      ["<Tab>"] = cmp.mapping(
        function(fallback)
          local cmp = require('cmp')
          if #cmp.core:get_sources() > 0 and not cmp.get_config().experimental.native_menu then
            if cmp.visible() then
              cmp.select_next_item()
            else
              cmp.complete()
            end
          else
            fallback()
          end
        end,
        {"i","s","c"}
      ),
      ['<S-Tab>'] = cmp.mapping({
        c = function(fallback)
          local cmp = require('cmp')
          if #cmp.core:get_sources() > 0 and not cmp.get_config().experimental.native_menu then
            if cmp.visible() then
              cmp.select_prev_item()
            else
              cmp.complete()
            end
          else
            fallback()
          end
        end,
      }),
      ['<CR>'] = cmp.mapping.confirm({
        behavior = cmp.ConfirmBehavior.Replace,
        select = true,
      })
    },
    sources = cmp.config.sources({
      { name = 'nvim_lsp' },
      -- { name = 'vsnip' }, -- For vsnip users.
      -- { name = 'luasnip' }, -- For luasnip users.
      -- { name = 'ultisnips' }, -- For ultisnips users.
      -- { name = 'snippy' }, -- For snippy users.
      },
      {
        { name = 'buffer' },
      })
  })

  -- Use buffer source for `/` (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline('/', {
    sources = {
      { name = 'buffer' }
    }
  })

  -- Use cmdline & path source for ':' (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline(':', {
    sources = cmp.config.sources({
      { name = 'path' }
    }, {
      { name = 'cmdline' }
    })
  })

  local capabilities = require('cmp_nvim_lsp').update_capabilities(vim.lsp.protocol.make_client_capabilities())

  -- Use an on_attach function to only map the following keys
  -- after the language server attaches to the current buffer
  local on_attach = function(client, bufnr)
    local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
    local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

    -- Enable completion triggered by <c-x><c-o>
    buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')

    -- Mappings.
    local opts = { noremap=true,}
    -- local opts = { noremap=true, silent=true }

    -- See `:help vim.lsp.*` for documentation on any of the below functions
    buf_set_keymap('n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
    buf_set_keymap('n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
    buf_set_keymap('n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
    buf_set_keymap('n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
    buf_set_keymap('n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
    buf_set_keymap('n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
    buf_set_keymap('n', '<space>wa', '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
    buf_set_keymap('n', '<space>wr', '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
    buf_set_keymap('n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
    buf_set_keymap('n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
    buf_set_keymap('n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
    buf_set_keymap('n', '<space>ca', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
    buf_set_keymap('n', '<space>e', '<cmd>lua vim.diagnostic.open_float()<CR>', opts)
    buf_set_keymap('n', '[d', '<cmd>lua vim.diagnostic.goto_prev()<CR>', opts)
    buf_set_keymap('n', ']d', '<cmd>lua vim.diagnostic.goto_next()<CR>', opts)
    buf_set_keymap('n', '<space>q', '<cmd>lua vim.diagnostic.setloclist()<CR>', opts)
    buf_set_keymap('n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)

  end

  -- Use a loop to conveniently call 'setup' on multiple servers and
  -- map buffer local keybindings when the language server attaches
  
  local lsp_config = require('lspconfig')
  local servers = { 'solargraph', 'gopls', 'tsserver' }
  for _, lsp in ipairs(servers) do
    lsp_config[lsp].setup {
      capabilities = capabilities,
      on_attach = on_attach,
      flags = {
        debounce_text_changes = 150,
      }
    }
  end

  require('lspfuzzy').setup {
    methods = 'all',         -- either 'all' or a list of LSP methods (see below)
    jump_one = true,         -- jump immediately if there is only one location
    callback = nil,          -- callback called after jumping to a location
    save_last = false,       -- save last location results for the :LspFuzzyLast command
    fzf_preview = {          -- arguments to the FZF '--preview-window' option
      'down:+{2}-/2'          -- preview on the right and centered on entry
    },
    fzf_action = {               -- FZF actions
      ['ctrl-t'] = 'tab split',  -- go to location in a new tab
      ['ctrl-v'] = 'vsplit',     -- go to location in a vertical split
      ['ctrl-x'] = 'split',      -- go to location in a horzontal split
    },
    fzf_modifier = ':~:.',   -- format FZF entries, see |filename-modifiers|
    fzf_trim = true,         -- trim FZF entries
  }
EOF
end


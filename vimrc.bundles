" Install vim-plug if not found
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://cdn.jsdelivr.net/gh/junegunn/vim-plug@master/plug.vim
endif

nnoremap <silent> <leader><leader>i :PlugInstall <CR>
"Run PlugInstall if there are missing plugins
"autocmd VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  "\| PlugInstall --sync | source $MYVIMRC
"\| endif

call plug#begin('~/.vim/bundle')
Plug 'sonph/onehalf', { 'rtp': 'vim' }
"Plug 'vim-airline/vim-airline'
"let g:airline_theme='onehalfdark'

" https://github.com/easymotion/vim-easymotion
Plug 'easymotion/vim-easymotion', {'on':
   \ [
   \ '<Plug>(easymotion-bd-f)', '<Plug>(easymotion-overwin-f)',
   \ '<Plug>(easymotion-bd-f2)', '<Plug>(easymotion-overwin-f2)',
   \ '<Plug>(easymotion-bd-jk)', '<Plug>(easymotion-overwin-line)',
   \ '<Plug>(easymotion-bd-w)', '<Plug>(easymotion-overwin-w)', 
   \ ]}

" disable default mappings
let g:EasyMotion_do_mapping = 0
" turn on case-insensitive feature
let g:EasyMotion_smartcase = 1
" `s{char}`
map f <Plug>(easymotion-bd-f)
nmap f <Plug>(easymotion-overwin-f)

" use s to quick search
" `s{char}{label}`
map s <Plug>(easymotion-bd-f2)
nmap s <Plug>(easymotion-overwin-f2)
" 无需输入字符，即可全屏搜索单词
"let g:EasyMotion_keys = 'abcdefghijklmnopqrstuvwx-^&*()+123456ABCDEF/;\=[]GHIJKLMNOPQRST7890UVWXYZyz'
" move to word
map  F <Plug>(easymotion-bd-w)
nmap F <Plug>(easymotion-overwin-w)

" move to line
map  gl <Plug>(easymotion-bd-jk)
nmap gl <Plug>(easymotion-overwin-line)

" https://github.com/preservim/nerdcommenter
Plug 'preservim/nerdcommenter'

Plug 'preservim/tagbar', { 'on': 'TagbarToggle' }
nnoremap <silent> <leader>m :TagbarToggle<CR>
silent! unmap <cr>
"Plug 'liuchengxu/vista.vim', {'on': ['Vista!!', 'Vista']}
"let g:vista#renderer#enable_icon = 1
"let g:vista#renderer#icons = {
    "\   "function": "\uf794",
    "\   "variable": "\uf71b",
    "\  }
"let g:vista_default_executive = 'coc'
"let g:vista_sidebar_width = 50
"nnoremap <leader>3 Vista!!<CR>

" fuzzy finder 
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
command! -bang -nargs=* Tags call fzf#vim#tags(<q-args>, fzf#vim#with_preview({ 'dir': systemlist('git rev-parse --show-toplevel 2>/dev/null || pwd')[0], "placeholder": "--tag {2}:{-1}:{3..}" }), <bang>0)
augroup update_bat_theme
    autocmd!
    autocmd colorscheme * call ToggleBatEnvVar()
augroup end
function ToggleBatEnvVar()
    if (&background == "dark")
        let $BAT_THEME='OneHalfDark'
    else
        let $BAT_THEME=''
    endif
endfunction

" jump to existed window if possible
let g:fzf_buffers_jump = 1
let g:fzf_history_dir = '~/.local/share/fzf-history'
if exists('$TMUX')
  let g:fzf_layout = { 'tmux': '-p90%,60%' }
else
  "disable popup in favor of location window
  let g:fzf_layout = { 'down': '40%' }

  "let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.9, 'relative': v:true, } }
endif

let $FZF_DEFAULT_OPTS="--reverse --preview-window 'down:75%'
  \ --bind ctrl-y:preview-up,ctrl-e:preview-down,
  \ctrl-u:half-page-up,ctrl-d:half-page-down,
  \ctrl-b:preview-half-page-up,ctrl-f:preview-half-page-down,
  \alt-u:preview-half-page-up,alt-d:preview-half-page-down,
  \shift-up:preview-top,shift-down:preview-bottom"

"search current dir
nnoremap <silent> <leader>sd :Files<Cr>
"search current files
nnoremap <silent> <Leader>sf :BLines<CR>
"search history
nnoremap <silent> <leader>sh :History<CR>

" `brew install ripgrep` before you use rg command
if executable('rg')
  let $FZF_DEFAULT_COMMAND='rg --files --hidden -g "!{.git}/*" 2>/dev/null'

  " search in current project or work dir
  function! YARG(query, fullscreen)
    let current_repo = trim(system('git rev-parse --show-toplevel 2>/dev/null || pwd'))
    let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case -- %s || true'
    
    let initial_command = printf(command_fmt, shellescape(a:query))
    call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview({'dir': systemlist('git rev-parse --show-toplevel 2>/dev/null || pwd')[0]}), a:fullscreen)
  endfunction

  command! -nargs=* -bang YARG call YARG(<q-args>, <bang>0)
  " search current project or current dir
  nnoremap <silent> <leader>sp :YARG<Cr>

  function! SearchWordWithRg()
    execute 'YARG' expand('<cword>')
  endfunction

  " search current word
  nnoremap <silent> <leader>sw :call SearchWordWithRg()<CR>
  " search selected word
  vnoremap <silent> <leader>sw y:YARG <c-r>"<cr>

  " Gem search
  function! GemSearch()
    call fzf#run(fzf#wrap({'source': "bundle list | sed '1d;$d' | cut -d ' ' -f 4", 'sink': {gem -> GemFileSearch(gem)}}))
  endfunction

  function! GemFileSearch(gem)
    let gemdir = substitute(system("bundle show " . a:gem), '\n\+$', '', '')
    call fzf#run(fzf#wrap({'source': 'rg --files ' . gemdir . ' --color never | sed -e "s#^' . gemdir . '/##"', 'dir': gemdir}), fzf#vim#with_preview())
  endfunction

  nnoremap <leader>sg :call GemSearch()<cr>
endif
" markdown preview
" npm -g install instant-markdown-d
Plug 'instant-markdown/vim-instant-markdown', {'for': 'markdown'}

Plug 'airblade/vim-gitgutter'

Plug 'tpope/vim-endwise'

" https://github.com/neoclide/coc.nvim
" brew install node
if executable('npm')
  Plug 'neoclide/coc.nvim', {'branch': 'release'}

  if has("nvim-0.5.0") || has("patch-8.1.1564")
    " Recently vim can merge signcolumn and number column into one
    set signcolumn=number
  else
    set signcolumn=yes
  endif

  inoremap <silent><expr> <TAB>
        \ pumvisible() ? "\<C-n>" :
        \ <SID>check_back_space() ? "\<TAB>" :
        \ coc#refresh()
  inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"
  function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~# '\s'
  endfunction

  " Use <c-space> to trigger completion.
  if has('nvim')
    inoremap <silent><expr> <c-space> coc#refresh()
  else
    inoremap <silent><expr> <c-@> coc#refresh()
  endif

  " Make <CR> auto-sele"ct the first completion item and notify coc.nvim to
  "" format on enter, <cr> could be remapped by other vim plugin
  "inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

  nmap <silent> gd <Plug>(coc-definition)
  nmap <silent> gy <Plug>(coc-type-definition)
  nmap <silent> gi <Plug>(coc-implementation)
  nmap <silent> gr <Plug>(coc-references)

  " Use K to show documentation in preview window.
  nnoremap <silent> K :call <SID>show_documentation()<CR>

  function! s:show_documentation()
    if (index(['vim','help'], &filetype) >= 0)
      execute 'h '.expand('<cword>')
    elseif (coc#rpc#ready())
      call CocActionAsync('doHover')
    else
      execute '!' . &keywordprg . " " . expand('<cword>')
    endif
  endfunction

  let g:coc_global_extensions = ['coc-explorer']
  nnoremap <leader>e <Cmd>CocCommand explorer<CR>
  " CoC Explorer Settings
  augroup coc_explorer_group
    autocmd!
    autocmd VimEnter * sil! au! F
    " set window status line
    autocmd FileType coc-explorer setl statusline=File-Explorer
    " quit explorer whein it's the last
    autocmd BufEnter * if (winnr("$") == 1 && &filetype == 'coc-explorer') | q | endif
    " Make sure nothing opened in coc-explorer buffer
    autocmd BufEnter * if bufname('#') =~# "\[coc-explorer\]-." && winnr('$') > 1 | b# | endif
   " cd after open
    autocmd User CocExplorerOpenPost let dir = getcwd() | call CocActionAsync("runCommand", "explorer.doAction", "closest", {"name": "cd", "args": [dir]})
  augroup END
  let g:coc_user_config = {                      
          \'explorer.keyMappings.global': {
            \ 'H': ["wait", 'collapse:recursive'],
            \ 'L': ["wait", 'expand:recursive'],
            \ 'gl': v:false,
            \}
          \}
          "\'explorer.icon.enableNerdfont': v:true,
          "\'explorer.file.column.icon.modified': '•',
          "\"explorer.file.column.icon.deleted": "✗",
          "\"explorer.file.column.icon.untracked": "★",
          "\"explorer.file.column.icon.renamed": "➜",
          "\"explorer.file.column.icon.unmerged": "",
          "\"explorer.file.column.icon.ignored": "ⁱ"

else
  Plug 'preservim/nerdtree'
  let NERDTreeMinimalUI = 1 " 最小化显示，不显示问号
  let NERDTreeDirArrows = 1
  let NERDChristmasTree = 1
  " 如果使用vim-plug的话，加上这一句可以避免光标在nerdtree
  " 中的时候进行插件升级而导致nerdtree崩溃
  let NERDTreeAutoDeleteBuffer = 1
  " 进入目录自动将workspace更改为此目录
  let g:NERDTreeChDirMode = 2

  nnoremap <leader>e :NERDTreeMirror<CR>:NERDTreeToggle<CR>
  nnoremap <C-f> :NERDTreeFind<CR>
  let g:NERDTreeMapOpenSplit = "s"
  let g:NERDTreeMapOpenVSplit = "E"
  " 展开与关闭节点或者打开文件
  let g:NERDTreeMapActivateNode = 'l'
  let g:NERDTreeMapOpenRecursively = 'L'
  let g:NERDTreeMapCloseDir = 'h'
  " 回到上一级目录
  let g:NERDTreeMapUpdirKeepOpen = '<backspace>'

  augroup nerdtree_group
    " Exit Vim if NERDTree is the only window remaining in the only tab.
    autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif

    " If another buffer tries to replace NERDTree, put it in the other window, and bring back NERDTree.
    autocmd BufEnter * if bufname('#') =~ 'NERD_tree_\d\+' && bufname('%') !~ 'NERD_tree_\d\+' && winnr('$') > 1 |
        \ let buf=bufnr() | buffer# | execute "normal! \<C-W>w" | execute 'buffer'.buf | endif
  augroup END
endif

"========================================= ruby develop environment =========================================
Plug 'vim-ruby/vim-ruby', { 'for': ['ruby'] }
Plug 'tpope/vim-bundler'
Plug 'tpope/vim-rails', { 'for': ['ruby'] }

"======================================== scheme develop environment ========================================
" lisp IDE
Plug 'vlime/vlime', {'rtp': 'vim/'}

Plug 'kovisoft/paredit', { 'for': ['clojure', 'scheme'] }
autocmd filetype lisp,scheme,art setlocal equalprg=scmindent.rkt

"===========================================================================================================

Plug 'mhinz/vim-startify'
" returns all modified files of the current git repo
" `2>/dev/null` makes the command fail quietly, so that when we are not
" in a git repo, the list will be empty
function! s:gitModified()
    let files = systemlist('git ls-files -m 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

" same as above, but show untracked files, honouring .gitignore
function! s:gitUntracked()
    let files = systemlist('git ls-files -o --exclude-standard 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

let g:startify_lists = [
        \ { 'type': 'sessions',  'header': ['   Sessions']       },
        \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
        \ { 'type': 'files',     'header': ['   MRU']            },
        \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
        \ { 'type': function('s:gitModified'),  'header': ['   git modified']},
        \ { 'type': function('s:gitUntracked'), 'header': ['   git untracked']},
        \ { 'type': 'commands',  'header': ['   Commands']       },
        \ ]
call plug#end()

colorscheme onehalfdark

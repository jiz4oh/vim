" Install vim-plug if not found
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://cdn.jsdelivr.net/gh/junegunn/vim-plug@master/plug.vim
endif

nnoremap <silent> <leader><leader>i :PlugInstall <CR>
set updatetime=100
"Run PlugInstall if there are missing plugins
"autocmd VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
  "\| PlugInstall --sync | source $MYVIMRC
"\| endif

" keep old clipboard
function! VisualSelection()
  let old_reg = getreg('"')
  let old_regtype = getregtype('"')
  let old_clipboard = &clipboard
  set clipboard&
  normal! ""gvy
  let selection = getreg('"')
  call setreg('"', old_reg, old_regtype)
  let &clipboard = old_clipboard
  return selection
endfunction
call plug#begin('~/.vim/bundle')
"==================== https://github.com/jiz4oh/vim#跳转 ====================
" https://github.com/easymotion/vim-easymotion
Plug 'easymotion/vim-easymotion', {'on':
   \ [
   \ '<Plug>(easymotion-bd-f)', '<Plug>(easymotion-overwin-f)',
   \ '<Plug>(easymotion-bd-jk)', '<Plug>(easymotion-overwin-line)',
   \ ]}

" disable default mappings
let g:EasyMotion_do_mapping = 0
" turn on case-insensitive feature
let g:EasyMotion_smartcase = 1
" `s{char}`
map f <Plug>(easymotion-bd-f)
nmap f <Plug>(easymotion-overwin-f)

" move to line
map  gl <Plug>(easymotion-bd-jk)
nmap gl <Plug>(easymotion-overwin-line)

"==================== https://github.com/jiz4oh/vim#搜索 ====================
" fuzzy finder 
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
let $FZF_DEFAULT_OPTS="--reverse
  \ --bind ctrl-b:page-up,ctrl-f:page-down,
  \alt-b:preview-page-up,alt-f:preview-page-down
  \"
let g:fzf_preview_window = [ 'down:50%' ]

" jump to existed window if possible
let g:fzf_buffers_jump = 1
let g:fzf_history_dir = '~/.local/share/fzf-history'
if exists('$TMUX')
  let g:fzf_layout = { 'tmux': '-p90%,60%' }
else
  "disable popup in favor of location window
  let g:fzf_layout = { 'down': '60%' }

  "let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.9, 'relative': v:true, } }
endif

Plug 'junegunn/fzf.vim'
command! -bang -nargs=* Tags call fzf#vim#tags(<q-args>, fzf#vim#with_preview({ 'dir': systemlist('git rev-parse --show-toplevel 2>/dev/null || pwd')[0], "placeholder": "--tag {2}:{-1}:{3..}" }), <bang>0)
augroup update_bat_theme
    autocmd!
    autocmd colorscheme * call ToggleBatEnvVar()
augroup end
function ToggleBatEnvVar()
    if (&background == "dark")
        let $BAT_THEME='OneHalfDark'
    else
        let $BAT_THEME=''
    endif
endfunction

" `brew install ripgrep` before you use rg command
if !executable('rg')
  function! s:git_grep(query, fullscreen, nth = 1)
    call fzf#vim#grep('git grep --line-number -- '.shellescape(a:query), 0, fzf#vim#with_preview({'dir': GitRepo(), 'options': ['--prompt', ' '.GitBranchName().'> ','--delimiter', ':', '--nth', a:nth.'..']}), a:fullscreen)
  endfunction

  function! Rg(query, fullscreen)
    echohl WarningMsg
    echom 'ripgrep not found'
    echohl None
    return 0
  endfunction
else
  set grepprg=rg\ --vimgrep\ --smart-case\ --follow
  set grepformat=%f:%l:%c:%m
  let $FZF_DEFAULT_COMMAND='rg --files --hidden -g "!{.git}/*" 2>/dev/null'
  let s:fzf_content_cmd = 'rg --column --line-number --no-heading --smart-case --follow --color=always %s || true'

  function! s:git_grep(query, fullscreen, nth = 1)
    let l:grep_cmd = printf(s:fzf_content_cmd, shellescape(a:query))
    call fzf#vim#grep(l:grep_cmd, 1, fzf#vim#with_preview({'dir': GitRepo(), 'options': ['--prompt', ' '.GitBranchName().'> ', '--delimiter', ':', '--nth', a:nth.'..']}), a:fullscreen)
  endfunction

  function! Rg(query, fullscreen)
    let l:grep_cmd = printf(s:fzf_content_cmd, shellescape(a:query))
    call fzf#vim#grep(l:grep_cmd, 1, fzf#vim#with_preview({'options': ['--prompt', getcwd().'> ', '--delimiter', ':', '--nth', 4.'..']}), a:fullscreen)
  endfunction
endif

function! s:fzf_content_shortcut(key, cmd)
  "nnoremap <silent> <leader>sp :Pg<Cr>
  execute 'nnoremap <leader>s' . a:key.' :' . a:cmd . '<CR>'

  "vnoremap <silent> <leader>sp :<C-u>execute ':Pg '.VisualSelection()<CR>
  execute "vnoremap <silent> <leader>s" . a:key . " :<C-u>execute ':" . a:cmd . " '.VisualSelection()<CR>"
endfunction

function! s:project_grep(query, fullscreen)
  if !empty(GitRepo())
    "search file name together in git repo
    try
      call s:git_grep(a:query, a:fullscreen)
    catch
      call Rg(a:query, a:fullscreen)
    endtry
  else
    "only search file content in cwd
    call Rg(a:query, a:fullscreen)
  endif
endfunction

command! -nargs=? -bang Rg        call Rg(<q-args>, <bang>0)
command! -nargs=? -bang Pg        call s:project_grep(<q-args>, <bang>0)
command! -nargs=? -bang GitGrep   call s:git_grep(<q-args>, <bang>0)
command! -nargs=? -bang GGrep     call s:git_grep(<q-args>, <bang>0)

nnoremap <silent> <leader>sd :Files<Cr>
nnoremap <silent> <leader>sh :History<CR>

call s:fzf_content_shortcut('b', 'BLines')
call s:fzf_content_shortcut('p', 'Pg')

"==================== https://github.com/jiz4oh/vim#git =====================
Plug 'airblade/vim-gitgutter'
Plug 'tpope/vim-fugitive'
" 添加当前文件到index
nnoremap <leader>gw :<C-U>Gwrite<cr>
" 提交
nnoremap <leader>gc :<C-U>Git commit<cr>
" 恢复当前文件到上个版本
nnoremap <leader>gr :<C-U>Gread<cr>
" 查看当前文件与提交文件的不同
nnoremap <leader>gf :<C-U>Gvdiffsplit<cr>
nnoremap <leader>gb :<C-U>Git blame<cr>
nnoremap <leader>gl :<C-U>Git log<cr>
nnoremap <leader>gs :<C-U>Git<cr>

"==================== https://github.com/jiz4oh/vim#文件浏览器 ==============
Plug 'preservim/nerdtree' |
      \ Plug 'Xuyuanp/nerdtree-git-plugin'

noremap <expr> <M-r> ':<C-u>%s/'.expand(call s:visual_selection()).'/' 
let g:NERDTreeGitStatusIndicatorMapCustom = {
  \ "Modified"  : "✹",
  \ "Staged"    : "✚",
  \ "Untracked" : "✭",
  \ "Renamed"   : "➜",
  \ "Unmerged"  : "═",
  \ "Deleted"   : "✖",
  \ "Dirty"     : "✗",
  \ "Clean"     : "✔︎",
  \ 'Ignored'   : '☒',
  \ "Unknown"   : "?"
  \ }

nnoremap <expr> <F1> g:NERDTree.IsOpen() ? ":NERDTreeClose\<CR>" : ":NERDTreeMirror\<CR>:NERDTreeFind\<CR>"

let NERDTreeMinimalUI = 1 " 最小化显示，不显示问号
let NERDTreeDirArrows = 1
let NERDChristmasTree = 1
" 如果使用vim-plug的话，加上这一句可以避免光标在nerdtree
" 中的时候进行插件升级而导致nerdtree崩溃
let NERDTreeAutoDeleteBuffer = 1
" 进入目录自动将workspace更改为此目录
let g:NERDTreeChDirMode = 2

"remove e mapping
let g:NERDTreeMapOpenExpl         = ''
let g:NERDTreeMapOpenSplit        = "w"
let g:NERDTreeMapOpenVSplit       = "W"
let g:NERDTreeMapActivateNode     = 'l'
let g:NERDTreeMapPreview          = 'gp'
let g:NERDTreeMapOpenRecursively  = 'L'
let g:NERDTreeMapCloseDir         = 'h'
let g:NERDTreeMapCloseChildren    = 'H'
let g:NERDTreeMapToggleHidden     = '.'
" 回到上一级目录
let g:NERDTreeMapUpdirKeepOpen    = '<backspace>'

function! s:NERDTreeCustomCROpen(node) abort
  let l:newRoot = a:node.GetSelected()

  if l:newRoot.path.isDirectory
    call b:NERDTree.changeRoot(l:newRoot)
  else
    call l:newRoot.activate({'reuse': 'all', 'where': 'p'})
  endif
endfunction

augroup nerdtree_group
  " Exit Vim if NERDTree is the only window remaining in the only tab.
  autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | quit | endif

  autocmd FileType nerdtree nmap <buffer> <CR> bb
  autocmd VimEnter * call NERDTreeAddKeyMap({
      \ 'key': 'bb',
      \ 'callback': function('<SID>NERDTreeCustomCROpen'),
      \ 'quickhelpText': 'go to dir and change cwd to it or open a file',
      \ 'scope': 'Node',
      \ 'override': 1,
      \ })
augroup END

"==================== https://github.com/jiz4oh/vim#补全 ====================
if has('nvim')
  "lsp
  Plug 'neovim/nvim-lspconfig'
  "autocomplte
  Plug 'hrsh7th/cmp-nvim-lsp'
  Plug 'hrsh7th/cmp-buffer'
  Plug 'hrsh7th/cmp-path'
  Plug 'hrsh7th/cmp-cmdline'
  Plug 'hrsh7th/nvim-cmp'
  "fzf integration
  "https://github.com/ojroques/nvim-lspfuzzy
  Plug 'ojroques/nvim-lspfuzzy'
endif

"==================== https://github.com/jiz4oh/vim#rails ===================
Plug 'vim-ruby/vim-ruby'
augroup ruby_aucmd
  autocmd!
  autocmd FileType ruby compiler ruby
  autocmd FileType eruby compiler eruby
augroup END
Plug 'tpope/vim-bundler'
Plug 'tpope/vim-rails'
Plug 'tpope/vim-dispatch'

function! s:set_buffer_relative_path(path)
  let b:buffer_relative_path = a:path
endfunction

augroup rails_aucmd
  autocmd User Rails :call <SID>set_buffer_relative_path(rails#buffer().relative())
augroup END

function! s:gem_content_search(gem, query, fullscreen)
  let l:gemdir = substitute(system("bundle show " . a:gem), '\n\+$', '', '')
  if has_key(s:, 'fzf_content_cmd')
    let l:grep_cmd = printf(s:fzf_content_cmd, shellescape(a:query))
  else
    let l:grep_cmd = 'find '. l:gemdir . ''
  endif
  call fzf#vim#grep(l:grep_cmd, 1, fzf#vim#with_preview({'dir': l:gemdir, 'options': ['--prompt', a:gem.'> ']}), a:fullscreen)
endfunction

" Gem search
function! s:gem_search(query, fullscreen)
  call fzf#vim#grep("bundle list | sed '1d;$d' | cut -d ' ' -f 4", 0, {'sink': {gem -> s:gem_content_search(gem, a:query, a:fullscreen)}}, a:fullscreen)
endfunction

" Gems search
function! s:gems_search(query, fullscreen) abort
  let b:project = bundler#project()
  if !empty(b:project)
    if !has_key(b:, 'gem_paths')
      let b:gem_paths = []
      for [gem, path] in items(b:project.paths())
        call add(b:gem_paths, path)
      endfor
    endif

    if has_key(s:, 'fzf_content_cmd')
      let l:grep_cmd = printf(s:fzf_content_cmd, shellescape(a:query) . ' ' . join(b:gem_paths, ' '))
    else
      let l:grep_cmd = 'find '. join(b:gem_paths, ' ') . ' -type f'
    endif
    call fzf#vim#grep(l:grep_cmd, 1, fzf#vim#with_preview({'options': ['--prompt', 'Gems> ']}), a:fullscreen)
  endif
endfunction

command! -nargs=? -bang Gem  call s:gem_search(<q-args>, <bang>0)
command! -nargs=? -bang Gems call s:gems_search(<q-args>, <bang>0)
call s:fzf_content_shortcut('g', 'Gems')

"==================== https://github.com/jiz4oh/vim#其他 ====================
Plug 'vlime/vlime', {'rtp': 'vim/'}

Plug 'kovisoft/paredit', { 'for': ['clojure', 'scheme'] }
autocmd filetype lisp,scheme,art setlocal equalprg=scmindent.rkt

Plug 'mhinz/vim-startify'
" returns all modified files of the current git repo
" `2>/dev/null` makes the command fail quietly, so that when we are not
" in a git repo, the list will be empty
function! s:gitModified()
    let files = systemlist('git ls-files -m 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

" same as above, but show untracked files, honouring .gitignore
function! s:gitUntracked()
    let files = systemlist('git ls-files -o --exclude-standard 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

let g:startify_lists = [
        \ { 'type': 'sessions',  'header': ['   Sessions']       },
        \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
        \ { 'type': 'files',     'header': ['   MRU']            },
        \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
        \ { 'type': function('s:gitModified'),  'header': ['   git modified']},
        \ { 'type': function('s:gitUntracked'), 'header': ['   git untracked']},
        \ { 'type': 'commands',  'header': ['   Commands']       },
        \ ]

Plug 'tpope/vim-commentary'
Plug 'tpope/vim-endwise'
Plug 'svermeulen/vim-cutlass'
nnoremap x d
xnoremap x d

nnoremap xx dd
nnoremap X D

" markdown preview
" npm -g install instant-markdown-d
Plug 'instant-markdown/vim-instant-markdown', {'for': 'markdown'}
Plug 'sonph/onehalf', { 'rtp': 'vim' }
Plug 'luochen1990/rainbow'
let g:rainbow_active = 1
"Plug 'vim-airline/vim-airline'
"let g:airline_theme='onehalfdark'

Plug 'preservim/tagbar', { 'on': 'TagbarToggle' }
nnoremap <silent> <leader>m :TagbarToggle<CR>

call plug#end()

colorscheme onehalfdark


"==================== https://github.com/jiz4oh/vim#补全 =====================
if has('nvim')
nnoremap gD <cmd>lua vim.lsp.buf.declaration()<CR>
nnoremap gd <cmd>lua vim.lsp.buf.definition()<CR>
nnoremap gr <cmd>lua vim.lsp.buf.references()<CR>
nnoremap gi <cmd>lua vim.lsp.buf.implementation()<CR>
nnoremap K <cmd>lua vim.lsp.buf.hover()<CR>
nnoremap <space>wa <cmd>lua vim.lsp.buf.add_workspace_folder()<CR>
nnoremap <space>wr <cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>
nnoremap <space>wl <cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>
nnoremap [d <cmd>lua vim.diagnostic.goto_prev()<CR>
nnoremap ]d <cmd>lua vim.diagnostic.goto_next()<CR>
nnoremap <space>f <cmd>lua vim.lsp.buf.formatting()<CR>

set completeopt=menu,menuone,noselect
lua << EOF
  local cmp = require'cmp'

  -- default config
  -- https://github.com/hrsh7th/nvim-cmp/blob/main/lua/cmp/config/default.lua
  cmp.setup({
    mapping = {
      ['<C-b>'] = cmp.mapping(cmp.mapping.scroll_docs(-4), { 'i', 'c' }),
      ['<C-f>'] = cmp.mapping(cmp.mapping.scroll_docs(4), { 'i', 'c' }),
      ['<CR>'] = cmp.mapping.confirm({
        behavior = cmp.ConfirmBehavior.Replace,
        select = false,
      })
    },
    sources = cmp.config.sources({
      { name = 'nvim_lsp' },
      -- { name = 'vsnip' }, -- For vsnip users.
      -- { name = 'luasnip' }, -- For luasnip users.
      -- { name = 'ultisnips' }, -- For ultisnips users.
      -- { name = 'snippy' }, -- For snippy users.
      },
      {
        { name = 'buffer' },
      })
  })

  -- Use buffer source for `/` (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline('/', {
    sources = {
      { name = 'buffer' }
    }
  })

  -- Use cmdline & path source for ':' (if you enabled `native_menu`, this won't work anymore).
  cmp.setup.cmdline(':', {
    sources = cmp.config.sources({
      { name = 'path' }
    }, {
      { name = 'cmdline' }
    })
  })

  local capabilities = require('cmp_nvim_lsp').update_capabilities(vim.lsp.protocol.make_client_capabilities())

  -- Use an on_attach function to only map the following keys
  -- after the language server attaches to the current buffer
  local on_attach = function(client, bufnr)
    local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

    -- Enable completion triggered by <c-x><c-o>
    buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')
  end

  -- Use a loop to conveniently call 'setup' on multiple servers and
  -- map buffer local keybindings when the language server attaches
  
  local lsp_config = require('lspconfig')
  local servers = { 'solargraph', 'gopls', 'tsserver' }
  for _, lsp in ipairs(servers) do
    lsp_config[lsp].setup {
      capabilities = capabilities,
      on_attach = on_attach,
      flags = {
        debounce_text_changes = 100,
      }
    }
  end

  require('lspfuzzy').setup {
    methods = 'all',         -- either 'all' or a list of LSP methods (see below)
    jump_one = true,         -- jump immediately if there is only one location
    callback = nil,          -- callback called after jumping to a location
    save_last = false,       -- save last location results for the :LspFuzzyLast command
    fzf_preview = {          -- arguments to the FZF '--preview-window' option
      'down:+{2}-/2'          -- preview on the right and centered on entry
    },
    fzf_action = {               -- FZF actions
      ['ctrl-t'] = 'tab split',  -- go to location in a new tab
      ['ctrl-v'] = 'vsplit',     -- go to location in a vertical split
      ['ctrl-x'] = 'split',      -- go to location in a horzontal split
    },
    fzf_modifier = ':~:.',   -- format FZF entries, see |filename-modifiers|
    fzf_trim = true,         -- trim FZF entries
  }
EOF
end

